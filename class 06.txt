에코 클라이언트 완벽 구현

에코 클라이언트 문제
read를 반복 하다가 읽을 내용이 없어 0을 리턴하면 종료
만약, 다음 데이터가 지연될 경우 다음 데이터를 읽지 않는 문제 발생

이는 보내고 받을 데이터 량이 정해져있지 않기 때문에 발생

수정 방향 -> 내가 보낸 데이터 길이를 저장해 뒀다가, 
수신하는 데이터 크기가 같을때 까지 수신하도록 해서 처리 == 명세 기반

명세 기반
최초 전달에 전송 데이터의 량을 명세함으로써 크기를 알수 있도록 하는 방식

프로토콜이 이런 역할을 함



TCP 소켓의 입출력 버퍼
read() == 입력 버퍼 내용을 읽어드림
write() == 출력 버퍼에 내용을 씀

버퍼의 데이터 량 관리는 TCP에서 처리함

소켓을 닫는 경우,
출력버퍼의 남은 데이터는 계속 전송 진행
입력버퍼(수신내용)의 데이터는 소멸 됨



상대 소켓과 연결
TCP경우 3 hand 쉐이킹 진행

1 클라이언트에서 -> 클라이언트의 주소와 포트번호 전달
2 서버에서 -> 새로만든 서버 소켓의 ip 주소와 포트번호 전달
3 클라이언트에서 -> 최종적 수신 ACK 응답


정상 데이터 전달
SEQ 1200 (100byte)에 대한 응답 == ACK 1301
다음 SEQ 1302 (100byte) "" == ACK 1402

만약 전송이후 ACK이 일정 시간 내에 안오면 Time OUT으로 재전송



close 상황 (four way hand shaking)
close 시 FIN 을 보내고 수신한 쪽에서 ACK를 보냄
다시 반대측에서 FIN을 보내고 최초 발신측은 ACK를 보내면서 끝남
이는, 반대측이 남은 작업을 처리 후 FIN을 보냄으로써 문제상황을 막음

그러나, close 경우 read 버퍼가 날라갈 수 있기 때문에,
read 버퍼 수신 내용을 유지하며 닫을 수 있는 방식이 필요함



Link Layer == 물리 네트워크 관련 프로토콜 정의
네트워크 레이어 == IP 프로토콜, 엔드투 엔드의 경로 설정

트랜스포트 레이어
 == TCP(신뢰성, 스트림에 따른 순서, 재전송 요청 등)
      UDP(재전송 안함, 신속성)


클라이언트
socket()
connect() == 내부에 bind가 포함됨
recv() / send()
close()

서버
socket()
bind()
listen()
accept()
send() / recv()


bind
socket에 주소(자신과, 타겟의 ip 주소와 port번호)를 할당

서버 측의 경우,
소켓이 여러개 일 수 있으며 bind된 peer주소(클라이언트의 주소)를 바탕으로
같은 주소와 같은 포트로 수신함에도 구분이 가능

accept()
핵심 == listen용 소켓이 아닌 자료 처리용 소켓이 새로 생성된다는 것



TCP의 경우 데이터 간 경계가 없음
ECHO client 에서 read시 모든데이터를 한번에 못읽는 경우가 발생할 수 도 있음
예제 코드에서는 보낸 만큼의 데이터량을 가지고 있다가, 수신량이 그를 충족 할 때까지 read를 하도록

Iterative Server의 while 문
EoF일때 0일 리턴하는 경우에 빠져나오게 된다.